# RNA-seq Analysis Workflow using Snakemake
# This workflow performs a comprehensive RNA-seq analysis from raw reads to differential

import pandas as pd
from pathlib import Path
import os

# Configuration
configfile: "config.yaml"

# Sample information
samples = pd.read_csv(config["samples"], sep="\t", index_col="sample")
SAMPLES = samples.index.tolist()

# Validate configuration
if not os.path.exists(config["reference"]["genome"]):
    raise FileNotFoundError(f"Genome reference file not found: {config['reference']['genome']}")
if not os.path.exists(config["reference"]["annotation"]):
    raise FileNotFoundError(f"Annotation file not found: {config['reference']['annotation']}")
                                                                              
# Determine if data is paired-end or single-end
PAIRED = config.get("paired_end", True)

# Target rule - defines the final outputs
rule all:
    input:
        # Quality control reports
        "results/qc/multiqc_report.html",
        # Alignment results
        expand("results/aligned/{sample}.sorted.bam", sample=SAMPLES),
        expand("results/aligned/{sample}.sorted.bam.bai", sample=SAMPLES),
        # Gene counts
        "results/counts/gene_counts_matrix.txt",
        # Differential expression results
        "results/deseq2/differential_expression_results.csv",
        "results/deseq2/pca_plot.png",
        "results/deseq2/ma_plot.png",
        "results/deseq2/volcano_plot.png",
        # Final report
        "results/workflow_report.html"

# Determine if data is paired-end or single-end
PAIRED = config.get("paired_end", True)

# Helper functions must be defined before using them in rules
def fastqc_inputs(sample):
    r1 = f"data/fastq/{sample}_R1.fastq.gz"
    if PAIRED:
        r2 = f"data/fastq/{sample}_R2.fastq.gz"
        return [r1, r2]
    else:
        return [r1]

def fastqc_outputs(sample):
    html = [f"results/qc/fastqc_raw/{sample}_R1_fastqc.html"]
    zip = [f"results/qc/fastqc_raw/{sample}_R1_fastqc.zip"]
    if PAIRED:
        html.append(f"results/qc/fastqc_raw/{sample}_R2_fastqc.html")
        zip.append(f"results/qc/fastqc_raw/{sample}_R2_fastqc.zip")
    return html, zip

# Quality control of raw reads
rule fastqc_raw:
    input:
        R1="data/fastq/{sample}_1.fastq.gz",
        R2="data/fastq/{sample}_2.fastq.gz"
    output:
        R1_html="results/qc/fastqc_raw/{sample}_1_fastqc.html",
        R2_html="results/qc/fastqc_raw/{sample}_2_fastqc.html",
        R1_zip="results/qc/fastqc_raw/{sample}_1_fastqc.zip",
        R2_zip="results/qc/fastqc_raw/{sample}_2_fastqc.zip"
    log:
        "logs/fastqc_raw/{sample}.log"
    threads: 2
    shell:
        """
        mkdir -p results/qc/fastqc_raw
        fastqc -t {threads} -o results/qc/fastqc_raw {input.R1} {input.R2} > {log} 2>&1
        """



# Adapter trimming and quality filtering

rule trim_adapters:
    input:
        r1="data/fastq/{sample}_1.fastq.gz",
        r2="data/fastq/{sample}_2.fastq.gz"
    output:
        r1_trimmed="results/trimmed/{sample}_R1.trimmed.fastq.gz",
        r2_trimmed="results/trimmed/{sample}_R2.trimmed.fastq.gz"
    log:
        "logs/trimming/{sample}.log"
    threads: 3
    conda:
        "envs/trimming.yaml"
    shell:
        """
        trimmomatic PE -threads {threads} \
            {input.r1} {input.r2} \
            {output.r1_trimmed} {output.r1_trimmed}.unpaired \
            {output.r2_trimmed} {output.r2_trimmed}.unpaired \
            ILLUMINACLIP:TruSeq3-PE.fa:2:30:10
        """

# Quality control of trimmed reads
rule fastqc_trimmed:
    input:
        r1="results/trimmed/{sample}_R1.trimmed.fastq.gz",
        r2="results/trimmed/{sample}_R2.trimmed.fastq.gz"  # for paired-end
    output:
        r1_html="results/qc/fastqc_trimmed/{sample}_R1.trimmed_fastqc.html",
        r1_zip="results/qc/fastqc_trimmed/{sample}_R1.trimmed_fastqc.zip",
        r2_html="results/qc/fastqc_trimmed/{sample}_R2.trimmed_fastqc.html",
        r2_zip="results/qc/fastqc_trimmed/{sample}_R2.trimmed_fastqc.zip"
    log:
        "logs/fastqc_trimmed/{sample}.log"
    threads: 2
    conda:
        "envs/qc.yaml"
    shell:
        """
        mkdir -p results/qc/fastqc_trimmed
        fastqc -t {threads} -o results/qc/fastqc_trimmed {input.r1} {input.r2} > {log} 2>&1
        """


# Build STAR genome index
rule star_index:
    input:
        fasta=config["reference"]["genome"],
        gtf=config["reference"]["annotation"]
    output:
        directory("results/star_index")
    log:
        "logs/star_index/star_index.log"
    threads: config["resources"]["star_index_threads"]
    shell:
        """
        mkdir -p results/star_index
        STAR --runThreadN {threads} \
             --runMode genomeGenerate \
             --genomeDir results/star_index \
             --genomeFastaFiles {input.fasta} \
             --sjdbGTFfile {input.gtf} \
             --sjdbOverhang 100 \
             > {log} 2>&1
        """


# Align reads with STAR
rule star_align:
    input:
        r1="results/trimmed/{sample}_R1.trimmed.fastq.gz" if PAIRED else "results/trimmed/{sample}.trimmed.fastq.gz",
        r2="results/trimmed/{sample}_R2.trimmed.fastq.gz" if PAIRED else None,
        index="results/star_index"
    output:
        bam=temp("results/aligned/{sample}.Aligned.out.bam"),
        log_final="results/aligned/{sample}.Log.final.out",
        log_out="results/aligned/{sample}.Log.out",
        log_progress="results/aligned/{sample}.Log.progress.out",
        sj_out="results/aligned/{sample}.SJ.out.tab"
    params:
        r2_flag=lambda wc, input: input.r2 if PAIRED else "",
        extra=config.get("alignment", {}).get("star_params",
            "--outSAMtype BAM Unsorted --readFilesCommand zcat "
            "--outFilterType BySJout --outFilterMultimapNmax 20 "
            "--alignSJoverhangMin 8 --alignSJDBoverhangMin 1 "
            "--outFilterMismatchNmax 999 --outFilterMismatchNoverLmax 0.04 "
            "--alignIntronMin 20 --alignIntronMax 1000000 --alignMatesGapMax 1000000"),
        prefix=lambda wc: f"results/aligned/{wc.sample}."
    threads: config.get("resources", {}).get("star_align_threads", 8)
    log:
        "logs/star_align/{sample}.log"
    conda:
        "envs/alignment.yaml"
    shell:
    	"""
    	STAR --genomeDir {input.index} \
         	--readFilesIn {input.r1} {input.r2} \
         	--readFilesCommand zcat \
         	--runThreadN {threads} \
         	--outFileNamePrefix results/aligned/{wildcards.sample}. \
         	--outSAMtype BAM Unsorted \
         	--outFilterType BySJout --outFilterMultimapNmax 20 \
         	--alignSJoverhangMin 8 --alignSJDBoverhangMin 1 \
         	--outFilterMismatchNoverLmax 0.06 \
         	--alignIntronMin 20 --alignIntronMax 1000000 \
         	--alignMatesGapMax 1000000
    	"""



# Sort and index BAM files
rule sort_bam:
    input:
        "results/aligned/{sample}.Aligned.out.bam"
    output:
        "results/aligned/{sample}.sorted.bam"
    threads: config.get("resources", {}).get("sort_threads", 4)
    log:
        "logs/sort_bam/{sample}.log"
    conda:
        "envs/alignment.yaml"
    shell:
        """
        samtools sort -@ {threads} -o {output} {input} > {log} 2>&1
        """

rule index_bam:
    input:
        "results/aligned/{sample}.sorted.bam"
    output:
        "results/aligned/{sample}.sorted.bam.bai"
    log:
        "logs/index_bam/{sample}.log"
    conda:
        "envs/alignment.yaml"
    shell:
        """
        samtools index {input} &> {log}
        """


# Count reads per gene using featureCounts
rule feature_counts:
    input:
        bams=expand("results/aligned/{sample}.sorted.bam", sample=SAMPLES),
        annotation=config["reference"]["annotation"]
    output:
        counts="results/counts/gene_counts_matrix.txt",
        summary="results/counts/gene_counts_matrix.txt.summary"
    params:
        extra=lambda wildcards: (
            "-g gene_id -t exon -Q 10 -B -C" + (" -p" if PAIRED else "")
        )
    threads: config.get("resources", {}).get("featurecounts_threads", 4)
    log:
        "logs/feature_counts/feature_counts.log"
    conda:
        "envs/quantification.yaml"
    shell:
        """
        featureCounts {params.extra} \
            -a {input.annotation} \
            -o {output.counts} \
            -T {threads} \
            {input.bams} \
            > {log} 2>&1
        """



# Differential expression analysis with DESeq2
rule deseq2_analysis:
    input:
        counts="results/counts/gene_counts_matrix.txt",
        samples=config["samples"]
    output:
        results="results/deseq2/differential_expression_results.csv",
        normalized_counts="results/deseq2/normalized_counts.csv",
        rlog_counts="results/deseq2/rlog_normalized_counts.csv",
        pca_plot="results/deseq2/pca_plot.png",
        ma_plot="results/deseq2/ma_plot.png",
        volcano_plot="results/deseq2/volcano_plot.png",
        heatmap="results/deseq2/sample_heatmap.png"
    params:
        contrast=config.get("differential_expression", {}).get("contrast", ["condition", "treatment", "control"]),
        alpha=config.get("differential_expression", {}).get("alpha", 0.05),
        lfc_threshold=config.get("differential_expression", {}).get("lfc_threshold", 1)
    log:
        "logs/deseq2/deseq2_analysis.log"
    conda:
        "envs/deseq2.yaml"
    script:
        "scripts/deseq2_analysis.R"

# MultiQC report generation
rule multiqc:
    input:
        fastqc_raw=expand("results/qc/fastqc_raw/{sample}_1_fastqc.zip", sample=SAMPLES) +
                   expand("results/qc/fastqc_raw/{sample}_2_fastqc.zip", sample=SAMPLES),
        fastqc_trimmed=expand("results/qc/fastqc_trimmed/{sample}_R1.trimmed_fastqc.zip", sample=SAMPLES),
        aligned=expand("results/aligned/{sample}.Log.final.out", sample=SAMPLES),
        summary="results/counts/gene_counts_matrix.txt.summary"
    output:
        html="results/qc/multiqc_report.html"
    log:
        "logs/multiqc/multiqc.log"
    shell:
        """
        mkdir -p results/qc
        multiqc results/qc/fastqc_raw/ results/qc/fastqc_trimmed/ results/aligned/ -o results/qc/ > {log} 2>&1
        """



# Generate final workflow report
rule generate_report:
    input:
        multiqc="results/qc/multiqc_report.html",
        deseq2="results/deseq2/differential_expression_results.csv"
    output:
        "results/workflow_report.html"
    log:
        "logs/report/generate_report.log"
    conda:
        "envs/reporting.yaml"
    script:
        "scripts/generate_report.py"

